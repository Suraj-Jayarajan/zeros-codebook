# TypeScript 101

- Superset of JS with Type checking
- Every js file is a valid ts file.

  ts file ---> TypeScript Compiler (TSC) ---> js file

### Benefits

- Static Typing
- Code Completion
- Refactoring
- Shorthand Notatios
- New Features

### Drawbacks

- Transpilation : A compilation step is involved, since browsers dont inherinty compile ts.
- Not ideal for small projects.

## Setup

### Installation

```bash
npm i -g typescript
```

### Check version

```bash
tsc -v
```

`tsc` : TypeScript Compiler

### Basic Compilations

```bash
tsc <filename>.ts
```

this will create a js file with the same filename. example `tsc index.ts` will compile and create `index.js`

### Compilation with tsconfig

```bash
tsc
```

#### Configure TSC

```bash
tsc --init
```

creates `tsconfig.json` where you can control the tsc configurations such as

- target: sets the target js version
- rootDir: sets sorce folder
- outDir: sets destination js folder
- removeComments: removes ts code
- noEmitOnError: force runs without error _(Not Reccommended)_


## Js Code Vs TS Code

```ts
/* ==== Js code ==== */
let ageJs = 25;
let messageJs = "John Doe";
console.log(`Name: ${messageJs}, Age: ${ageJs}`);

/* ==== Ts code ==== */
let age: number = 25;
let message: string = "John Doe";
console.log(`Name: ${message}, Age: ${age}`);
```

## TS Debugger

> TODO: Learn settings

## Types

#### Js Types (included in ts)

- number
- string
- boolean
- null
- undefined
- object
- array

#### Ts Types

- any (default value, recommeneded to not use this)
- unkonwn
- never
- enum
- tuple

```ts
let num; // any
let num: number = 500000;
let num = 500000; // Auto identified as number
let num = 5_00_000; // num formated = 500000
let nums = []; // nums: any[]
let nums: number[] = []; // numbers array
let mixed = [1, "1", false];
let mixed: (string | number)[] = [];
```

#### Tuples (value pairs)

```ts
let users: [number, string] = [1, "Suraj"];
```

**Best Practices:**

- Restrict tuples to only two values

#### Enums

```ts
const enums Size {Small = 's', Medium = 'm', Large = 'l'}
```

#### Functions

```ts
function calulatorTax(income: number): number {
  return 0;
}

let calculateTax: Function;

calulateTax = (income: number, slab?: number): number => 0;
```

**Best Practices**

- in ts config set these parameters to true
  - `noUnusedParameters`: Throws error if function parameters are unused
  - `noUnusedLocals`: Throws error if function conatins unsused variables
  - `noImplicitReturns`: Throws error if function return value other than provided data type, because by default it is allowed to throw undefined.

#### Objects

```js
let employee: {
  readonly id: number
  name: string
} = {
  id: 1,
  name: 'Suraj'
}
```

## Type Aliases (Custom Type/Models Approach)

```ts
type Employee = {
  readonly id: number,
  name: string,
  retireOn: (date: Date) => void
}

let employee: Employee = {
  id: 1,
  name: 'Suraj'
  retireOn: (date: Date) => {
    console.log(date)
  }
}
```

## Union Types (OR types)

```ts
let weight = number | string;
```

## Intersection Types (AND types)

```ts
let weight = number & string; // This is not possible in real case scenario with primitive types. Look at another example

type Draggable = {
  drag: () => void;
};

type Resizable = {
  resize: () => void;
};

type UIWidget = Draggable & Resizable; // this is also multiple inheritance
```

## Literal Types (exact, specific value)

```ts
type Quantity = 50 | 100;

let quantity: Quantity = 100; // quantity can only be 50 or 100

type Metric = "cm" | "inch"; // example
```

## Nullable Values

> By default tsc does not allow null/undefined values. Since they are the most common source of runtime errors

#### Defining Nullable Values

```ts
let nullableValue: number | null | undefined = null;
```

#### Optional property access operator (?.)

```ts
customer?.birthday?.getFullYear();
```

#### Optional element access operator (?. for array elements)

```ts
customer?.[0];
```

#### Optional Call (?. for functions)

```ts
fnName?.("param1");
```

## DOM Interactions

> TODO

## Classes
